<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Pendinha Boss Shooter</title>
<style>
  * { box-sizing: border-box; }
  html, body {
    margin: 0; padding: 0; height: 100%; background: #000;
    font-family: 'Arial', sans-serif; color: #fff; touch-action: manipulation;
  }
  #gameContainer {
    position: relative; max-width: 420px; margin: 0 auto; height: 100%;
    display: flex; align-items: center; justify-content: center; background: #000;
  }
  canvas { display: block; background: #000; image-rendering: pixelated; }
  #ui, #lives, #currentWeapon, #fullScreenBtn {
    position: absolute; z-index: 10; pointer-events: none; user-select: none;
  }
  #ui { top: 12px; left: 12px; font-size: 15px; font-weight: bold; }
  #lives { top: 12px; right: 12px; font-size: 28px; }
  #currentWeapon { bottom: 12px; left: 12px; font-size: 14px; color: #00e5ff; }
  #fullScreenBtn {
    bottom: 12px; right: 12px; padding: 10px 14px; background: rgba(0,229,255,0.9);
    color: #000; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;
    pointer-events: auto;
  }
  #menu, #gameOverScreen, #shipSelection {
    position: absolute; inset: 0; background: rgba(0,0,0,0.94);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 20; text-align: center;
  }
  #menu { display: flex; }
  #gameOverScreen, #shipSelection { display: none; }
  #menu h1, #shipSelection h1 { font-size: 36px; margin-bottom: 10px; }
  #menu p, #shipSelection p { margin: 10px 0; opacity: 0.9; font-size: 14px; }
  button {
    padding: 14px 36px; font-size: 20px; margin: 10px;
    background: #00e5ff; color: #000; border: none; border-radius: 10px;
    cursor: pointer; font-weight: bold;
  }
  button:active { transform: scale(0.95); }
  #gameOverScreen h1 { color: #ff1744; }
  #shipSelection button { width: 200px; }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="game"></canvas>
  <div id="ui">
    Fase: <span id="phase">1</span><br>
    Score: <span id="score">0</span>
  </div>
  <div id="lives">仇벒잺仇벒잺仇벒잺</div>
  <div id="currentWeapon">Arma: B치sica</div>
  <button id="fullScreenBtn">游닠 Tela Cheia</button>

  <div id="menu">
    <h1>游 Pendinha Boss Shooter</h1>
    <p>Toque ou mova o mouse para controlar<br>Segure para atirar</p>
    <button id="selectShipBtn">Escolher Nave</button>
  </div>

  <div id="shipSelection">
    <h1>Escolha sua Nave</h1>
    <button id="fighterBtn">Ca칞a</button>
    <p>R치pida, equilibrada, arma padr칚o</p>
    <button id="mothershipBtn">Nave-M칚e</button>
    <p>Lenta, resistente, arma pesada</p>
    <button id="scoutBtn">Explorador</button>
    <p>Muito r치pida, fr치gil, arma precisa</p>
  </div>

  <div id="gameOverScreen">
    <h1>游 Game Over</h1>
    <p>Score Final: <span id="finalScore">0</span></p>
    <p>Fase Alcan칞ada: <span id="finalPhase">1</span></p>
    <button id="restartBtn">Jogar Novamente</button>
  </div>
</div>

<script>
// ================ CONFIGURA칂칏ES ================
const CONFIG = {
  canvas: { width: 360, height: 520 },
  ships: {
    fighter: {
      size: 16,
      speed: 0.18,
      maxLives: 3,
      weapons: {
        basic: { name: "B치sica", cooldown: 12, bullet: { vy: -7, r: 3, damage: 5 } },
        double: { name: "Dupla", cooldown: 14, damage: 8 },
        spread: { name: "Espalhada", cooldown: 16, damage: 7 },
        rapid: { name: "R치pida", cooldown: 6, bullet: { vy: -10, r: 2, damage: 6 } },
        laser: { name: "Laser", cooldown: 10, bullet: { vy: -14, r: 2, laser: true, damage: 12 } },
        missile: { name: "M칤ssil", cooldown: 20, bullet: { vy: -5, r: 5, damage: 15, homing: true } }
      }
    },
    mothership: {
      size: 20,
      speed: 0.12,
      maxLives: 4,
      weapons: {
        basic: { name: "Canh칚o Pesado", cooldown: 18, bullet: { vy: -6, r: 5, damage: 8 } },
        double: { name: "Dupla", cooldown: 14, damage: 8 },
        spread: { name: "Espalhada", cooldown: 16, damage: 7 },
        rapid: { name: "R치pida", cooldown: 6, bullet: { vy: -10, r: 2, damage: 6 } },
        laser: { name: "Laser", cooldown: 10, bullet: { vy: -14, r: 2, laser: true, damage: 12 } },
        missile: { name: "M칤ssil", cooldown: 20, bullet: { vy: -5, r: 5, damage: 15, homing: true } }
      }
    },
    scout: {
      size: 12,
      speed: 0.24,
      maxLives: 2,
      weapons: {
        basic: { name: "Tiro Preciso", cooldown: 10, bullet: { vy: -9, r: 2, damage: 4 } },
        double: { name: "Dupla", cooldown: 14, damage: 8 },
        spread: { name: "Espalhada", cooldown: 16, damage: 7 },
        rapid: { name: "R치pida", cooldown: 6, bullet: { vy: -10, r: 2, damage: 6 } },
        laser: { name: "Laser", cooldown: 10, bullet: { vy: -14, r: 2, laser: true, damage: 12 } },
        missile: { name: "M칤ssil", cooldown: 20, bullet: { vy: -5, r: 5, damage: 15, homing: true } }
      }
    }
  },
  powerUpDuration: 600,
  allyDuration: 1800 // 30 segundos a ~60 FPS
};

// ================ ESTADO GLOBAL ================
let gameState = 'menu';
let score = 0;
let phase = 1;
let lives = 3;
let currentWeapon = 'basic';
let weaponTimer = 0;
let ally = null;
let currentShip = 'fighter'; // Nave padr칚o

// ================ CANVAS E INPUT ================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = CONFIG.canvas.width;
canvas.height = CONFIG.canvas.height;

const input = { x: canvas.width / 2, y: canvas.height - 80, active: false };

['mousemove', 'touchmove'].forEach(ev => {
  canvas.addEventListener(ev, e => {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    input.x = (clientX - rect.left) * (canvas.width / rect.width);
    input.y = (clientY - rect.top) * (canvas.height / rect.height);
  });
});

['mousedown', 'touchstart'].forEach(ev => {
  canvas.addEventListener(ev, e => { e.preventDefault(); input.active = true; });
});
['mouseup', 'touchend', 'touchcancel'].forEach(ev => {
  canvas.addEventListener(ev, () => input.active = false);
});

// ================ ENTIDADES ================
class Player {
  constructor() {
    this.reset();
  }
  reset() {
    this.x = canvas.width / 2;
    this.y = canvas.height - 60;
    this.cooldown = 0;
    this.bullets = [];
    this.shipType = currentShip;
    this.size = CONFIG.ships[this.shipType].size;
    this.speed = CONFIG.ships[this.shipType].speed;
  }
  update() {
    this.x += (input.x - this.x) * this.speed;
    this.y += (input.y - this.y) * this.speed;
    this.x = Math.clamp(this.x, this.size, canvas.width - this.size);
    this.y = Math.clamp(this.y, this.size, canvas.height - this.size);

    if (this.cooldown > 0) this.cooldown--;
    if (input.active && this.cooldown <= 0) {
      this.shoot();
      this.cooldown = CONFIG.ships[this.shipType].weapons[currentWeapon].cooldown || 12;
    }

    for (let i = this.bullets.length - 1; i >= 0; i--) {
      const b = this.bullets[i];
      if (b.homing) {
        let target = { x: boss.x, y: boss.y, dist: Math.hypot(b.x - boss.x, b.y - boss.y) };
        [...enemies, ...shooterEnemies].forEach(e => {
          const d = Math.hypot(b.x - e.x, b.y - e.y);
          if (d < target.dist) target = { x: e.x, y: e.y, dist: d };
        });
        if (target.dist < 300) {
          const angle = Math.atan2(target.y - b.y, target.x - b.x);
          b.vx = Math.cos(angle) * 5;
          b.vy = Math.sin(angle) * 5;
        }
      }
      b.x += b.vx || 0;
      b.y += b.vy;
      if (b.y < -50 || b.x < -50 || b.x > canvas.width + 50) {
        this.bullets.splice(i, 1);
      }
    }
  }
  shoot() {
    const w = CONFIG.ships[this.shipType].weapons[currentWeapon];
    const baseDamage = w.damage || w.bullet?.damage || 5;
    if (currentWeapon === 'double') {
      this.bullets.push(
        { x: this.x - 12, y: this.y - 10, vx: 0, vy: -8, r: 4, damage: baseDamage },
        { x: this.x + 12, y: this.y - 10, vx: 0, vy: -8, r: 4, damage: baseDamage }
      );
    } else if (currentWeapon === 'spread') {
      [-0.4, 0, 0.4].forEach(a => {
        const speed = 7;
        this.bullets.push({
          x: this.x, y: this.y - 10,
          vx: Math.cos(-Math.PI/2 + a) * speed,
          vy: Math.sin(-Math.PI/2 + a) * speed,
          r: 3, damage: baseDamage
        });
      });
    } else if (currentWeapon === 'missile') {
      this.bullets.push({
        x: this.x, y: this.y - 12, vx: 0, vy: w.bullet.vy, r: w.bullet.r,
        damage: baseDamage, homing: true
      });
    } else {
      const bullet = { x: this.x, y: this.y - 12, vx: 0, ...w.bullet, damage: baseDamage };
      this.bullets.push(bullet);
    }
  }
  draw() {
    if (this.shipType === 'mothership') {
      ctx.fillStyle = '#0288d1';
      ctx.beginPath();
      ctx.moveTo(this.x, this.y - 18);
      ctx.lineTo(this.x - 18, this.y + 12);
      ctx.lineTo(this.x + 18, this.y + 12);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(this.x - 8, this.y - 10, 16, 4);
    } else if (this.shipType === 'scout') {
      ctx.fillStyle = '#ffeb3b';
      ctx.beginPath();
      ctx.moveTo(this.x, this.y - 10);
      ctx.lineTo(this.x - 8, this.y + 10);
      ctx.lineTo(this.x + 8, this.y + 10);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(this.x, this.y - 2, 2, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.fillStyle = '#00e5ff';
      ctx.beginPath();
      ctx.moveTo(this.x, this.y - 14);
      ctx.lineTo(this.x - 12, this.y + 12);
      ctx.lineTo(this.x + 12, this.y + 12);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(this.x, this.y + 2, 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

class Boss {
  constructor() { this.reset(); }
  reset() {
    this.x = canvas.width / 2;
    this.y = 90;
    this.radius = 36;
    this.maxLife = 300 + (phase - 1) * 120;
    this.life = this.maxLife;
    this.bullets = [];
    this.shootTimer = 0;
    this.pattern = (phase - 1) % 3;
  }
  update() {
    const diff = 1 + (phase - 1) * 0.15;
    const delay = Math.max(90 - (phase - 1) * 8, 35);
    if (++this.shootTimer >= delay) {
      this.shootTimer = 0;
      this.shoot(diff);
    }

    for (let i = this.bullets.length - 1; i >= 0; i--) {
      const b = this.bullets[i];
      b.x += Math.cos(b.angle) * b.speed;
      b.y += Math.sin(b.angle) * b.speed;
      if (b.x < -50 || b.x > canvas.width + 50 || b.y < -50 || b.y > canvas.height + 50) {
        this.bullets.splice(i, 1);
      }
    }
  }
  shoot(diff) {
    if (this.pattern === 0) {
      const count = 6 + Math.floor(phase / 3);
      for (let i = -Math.floor(count / 2); i <= Math.floor(count / 2); i++) {
        this.bullets.push({ x: this.x, y: this.y, angle: Math.PI / 2 + i * 0.22, speed: 2.6 * diff, r: 6 });
      }
    } else if (this.pattern === 1) {
      for (let i = -3; i <= 3; i++) {
        this.bullets.push({ x: this.x + i * 16, y: this.y, angle: Math.PI / 2, speed: 3.2 * diff, r: 5 });
      }
    } else {
      const count = 10 + phase;
      for (let i = 0; i < count; i++) {
        const angle = i * Math.PI * 2 / count + performance.now() * 0.001;
        this.bullets.push({ x: this.x, y: this.y, angle, speed: 2.4 * diff, r: 5 });
      }
    }
  }
  draw() {
    ctx.fillStyle = '#b71c1c';
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#ff1744';
    ctx.beginPath();
    ctx.arc(this.x, this.y - 8, 12, 0, Math.PI * 2);
    ctx.fill();

    const barW = 160;
    ctx.fillStyle = '#333';
    ctx.fillRect(this.x - barW / 2, this.y - 56, barW, 10);
    ctx.fillStyle = '#4caf50';
    ctx.fillRect(this.x - barW / 2, this.y - 56, barW * (this.life / this.maxLife), 10);
  }
}

// ================ OUTRAS ENTIDADES ================
const player = new Player();
let boss = new Boss();

const particles = [];
const powerUps = [];
const enemies = [];
const shooterEnemies = [];

let shake = 0;
let bgOffset = 0;
let stars = [];

for (let i = 0; i < 80; i++) {
  stars.push({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    size: Math.random() * 2 + 1,
    speed: Math.random() * 0.5 + 0.2
  });
}

const bgColors = [
  ["#0b1d13","#1b5e20"], ["#102027","#263238"], ["#1a237e","#0d47a1"],
  ["#311b92","#512da8"], ["#3e2723","#5d4037"], ["#004d40","#00695c"]
];

function spawnParticles(x, y, color = '#ff1744', count = 20) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.5) * 6,
      life: 30 + Math.random() * 20,
      color
    });
  }
}

function triggerShake(amount = 8) {
  shake = Math.max(shake, amount);
}

function spawnPowerUp(x, y) {
  const types = ['double', 'spread', 'rapid', 'laser', 'missile'];
  let type = types[Math.floor(Math.random() * types.length)];
  if (Math.random() < 0.12 && lives < CONFIG.ships[currentShip].maxLives) type = 'life';
  if (Math.random() < 0.10) type = 'ally';
  powerUps.push({ x, y, type, vy: 1.4, r: 14 });
}

// ================ UPDATE ================
function update() {
  if (gameState !== 'playing') return;

  player.update();
  boss.update();

  if (shake > 0) shake = Math.max(0, shake - 0.6);

  // Atualiza estrelas do fundo
  stars.forEach(s => {
    s.y += s.speed + phase * 0.05;
    if (s.y > canvas.height) s.y = 0;
  });

  if (Math.random() < 0.018 + phase * 0.004) {
    enemies.push({
      x: Math.random() * (canvas.width - 40) + 20,
      y: -30,
      size: Math.random() < 0.3 ? 18 : 12,
      life: Math.random() < 0.3 ? 3 : 1,
      vy: 1.4 + phase * 0.1
    });
  }

  if (Math.random() < 0.006 + phase * 0.0015) {
    shooterEnemies.push({
      x: Math.random() * (canvas.width - 40) + 20,
      y: -40,
      size: 20,
      life: 4,
      vy: 1.1 + phase * 0.1,
      shootTimer: Math.random() * 40
    });
  }

  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    e.y += e.vy;
    if (e.y > canvas.height + 40) enemies.splice(i, 1);
  }

  for (let i = shooterEnemies.length - 1; i >= 0; i--) {
    const se = shooterEnemies[i];
    se.y += se.vy;
    if (++se.shootTimer >= 60) {
      se.shootTimer = 0;
      boss.bullets.push({
        x: se.x, y: se.y + se.size, angle: Math.PI / 2,
        speed: 3 + phase * 0.1, r: 4
      });
    }
    if (se.y > canvas.height + 40) shooterEnemies.splice(i, 1);
  }

  for (let i = powerUps.length - 1; i >= 0; i--) {
    const p = powerUps[i];
    p.y += p.vy;
    if (Math.hypot(p.x - player.x, p.y - player.y) < player.size + p.r) {
      applyPowerUp(p.type);
      spawnParticles(p.x, p.y, '#00ff80', 35);
      powerUps.splice(i, 1);
    } else if (p.y > canvas.height + 30) {
      powerUps.splice(i, 1);
    }
  }

  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }

  checkCollisions();

  if (weaponTimer > 0 && --weaponTimer === 0) {
    currentWeapon = 'basic';
    document.getElementById('currentWeapon').textContent = 'Arma: ' + CONFIG.ships[currentShip].weapons.basic.name;
  }

  if (ally) {
    ally.timer--;
    ally.x += (player.x + ally.offset - ally.x) * 0.12;
    ally.y += (player.y - 50 - ally.y) * 0.1;
    if (ally.shootTimer-- <= 0) {
      player.bullets.push({ x: ally.x, y: ally.y, vx: 0, vy: -9, r: 3, damage: 6 });
      ally.shootTimer = 16;
    }
    if (ally.timer <= 0) {
      spawnParticles(ally.x, ally.y, '#00ff80', 20);
      ally = null;
    }
  }
}

function applyPowerUp(type) {
  if (type === 'life') {
    lives = Math.min(lives + 1, CONFIG.ships[currentShip].maxLives);
    updateLives();
  } else if (type === 'ally') {
    ally = { x: player.x - 60, y: player.y - 40, offset: -60, timer: CONFIG.allyDuration, shootTimer: 0 };
  } else {
    currentWeapon = type;
    weaponTimer = CONFIG.powerUpDuration;
    document.getElementById('currentWeapon').textContent = 'Arma: ' + CONFIG.ships[currentShip].weapons[type].name;
  }
}

// ================ COLIS칏ES ================
function checkCollisions() {
  for (let i = player.bullets.length - 1; i >= 0; i--) {
    const b = player.bullets[i];
    if (Math.hypot(b.x - boss.x, b.y - boss.y) < boss.radius + (b.r || 3)) {
      boss.life -= b.damage || 5;
      player.bullets.splice(i, 1);
      spawnParticles(boss.x, boss.y, '#ff5722', 15);
      triggerShake(8);
      if (boss.life <= 0) {
        score += 1000 + phase * 300;
        phase++;
        updateUI();
        boss.reset();
        triggerShake(20);
        spawnParticles(boss.x, boss.y, '#ffeb3b', 80);
        spawnPowerUp(boss.x - 30, boss.y);
        spawnPowerUp(boss.x + 30, boss.y);
      }
    }
  }

  const allEnemies = [...enemies, ...shooterEnemies];
  for (let ei = allEnemies.length - 1; ei >= 0; ei--) {
    const e = allEnemies[ei];
    for (let bi = player.bullets.length - 1; bi >= 0; bi--) {
      const b = player.bullets[bi];
      if (Math.hypot(b.x - e.x, b.y - e.y) < e.size + (b.r || 3)) {
        e.life -= b.damage || 5;
        player.bullets.splice(bi, 1);
        spawnParticles(e.x, e.y, '#ff9800', 10);
        if (e.life <= 0) {
          score += e.size > 15 ? 60 : 30;
          updateUI();
          spawnParticles(e.x, e.y, '#ff5722', 20);
          const index = allEnemies.indexOf(e);
          if (index > -1) allEnemies.splice(index, 1);
          if (enemies.includes(e)) enemies.splice(enemies.indexOf(e), 1);
          else shooterEnemies.splice(shooterEnemies.indexOf(e), 1);
          if (Math.random() < 0.3) spawnPowerUp(e.x, e.y);
          break;
        }
      }
    }
  }

  const threats = [...boss.bullets, ...enemies, ...shooterEnemies];
  for (let i = threats.length - 1; i >= 0; i--) {
    const obj = threats[i];
    const radius = obj.r || obj.size || 0;
    if (radius > 0 && Math.hypot(obj.x - player.x, obj.y - player.y) < radius + player.size) {
      lives--;
      updateLives();
      triggerShake(14);
      spawnParticles(player.x, player.y, '#ff1744', 50);
      if (obj.r) boss.bullets.splice(boss.bullets.indexOf(obj), 1);
      if (lives <= 0) {
        gameOver();
        return;
      }
    }
  }
}

// ================ RENDER ================
function drawBackground() {
  const colors = bgColors[(phase - 1) % bgColors.length];
  const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grad.addColorStop(0, colors[0]);
  grad.addColorStop(1, colors[1]);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Estrelas animadas
  ctx.fillStyle = '#ffffff';
  stars.forEach(s => {
    ctx.globalAlpha = Math.sin(performance.now() * 0.001 + s.x) * 0.3 + 0.7;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  // Part칤culas de fundo (nebulosa leve)
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  for (let i = 0; i < 15; i++) {
    const x = (i * 60 + bgOffset * 0.5) % canvas.width;
    const y = (i * 100 + bgOffset * 0.3) % canvas.height;
    ctx.beginPath();
    ctx.arc(x, y, 30, 0, Math.PI * 2);
    ctx.fill();
  }
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBackground();

  let shakeX = 0, shakeY = 0;
  if (shake > 0) {
    shakeX = (Math.random() - 0.5) * shake;
    shakeY = (Math.random() - 0.5) * shake;
    ctx.translate(shakeX, shakeY);
  }

  if (gameState === 'playing') {
    boss.draw();
    boss.bullets.forEach(b => {
      ctx.fillStyle = '#ff5252';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();
    });

    enemies.forEach(e => {
      ctx.fillStyle = e.size > 15 ? '#ff5722' : '#ff9800';
      ctx.beginPath();
      ctx.moveTo(e.x, e.y - e.size);
      ctx.lineTo(e.x - e.size, e.y + e.size);
      ctx.lineTo(e.x + e.size, e.y + e.size);
      ctx.closePath();
      ctx.fill();
    });

    shooterEnemies.forEach(se => {
      ctx.fillStyle = '#795548';
      ctx.beginPath();
      ctx.moveTo(se.x, se.y - se.size);
      ctx.lineTo(se.x - se.size, se.y + se.size);
      ctx.lineTo(se.x + se.size, se.y + se.size);
      ctx.closePath();
      ctx.fill();
    });

    powerUps.forEach(p => {
      const colors = {
        double: '#ffeb3b', spread: '#e91e63', rapid: '#00bcd4',
        laser: '#00ff80', missile: '#ff5722', life: '#f44336', ally: '#8bc34a'
      };
      ctx.fillStyle = colors[p.type] || '#fff';
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.stroke();
    });

    if (ally) {
      ctx.fillStyle = '#00ff80';
      ctx.beginPath();
      ctx.moveTo(ally.x, ally.y - 12);
      ctx.lineTo(ally.x - 10, ally.y + 10);
      ctx.lineTo(ally.x + 10, ally.y + 10);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(ally.x, ally.y - 2, 3, 0, Math.PI * 2);
      ctx.fill();
    }

    player.bullets.forEach(b => {
      if (b.homing) {
        ctx.fillStyle = '#ff5722';
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ff1744';
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r - 2, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.fillStyle = b.laser ? '#00ff80' : '#00e5ff';
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r || 3, 0, Math.PI * 2);
        ctx.fill();
      }
    });

    player.draw();

    particles.forEach(p => {
      ctx.globalAlpha = p.life / 50;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
    });
    ctx.globalAlpha = 1;
  }

  if (shake > 0) ctx.translate(-shakeX, -shakeY);
}

function loop() {
  bgOffset += 0.3;
  update();
  render();
  requestAnimationFrame(loop);
}

// ================ UI E CONTROLES ================
function updateUI() {
  document.getElementById('score').textContent = score;
  document.getElementById('phase').textContent = phase;
}

function updateLives() {
  document.getElementById('lives').textContent = '仇벒잺'.repeat(lives);
}

function gameOver() {
  gameState = 'gameover';
  document.getElementById('finalScore').textContent = score;
  document.getElementById('finalPhase').textContent = phase;
  document.getElementById('gameOverScreen').style.display = 'flex';
}

function showShipSelection() {
  document.getElementById('menu').style.display = 'none';
  document.getElementById('shipSelection').style.display = 'flex';
  document.getElementById('gameOverScreen').style.display = 'none';
}

function startGame() {
  score = 0;
  phase = 1;
  lives = CONFIG.ships[currentShip].maxLives;
  currentWeapon = 'basic';
  weaponTimer = 0;
  ally = null;

  player.reset();
  boss.reset();

  particles.length = 0;
  powerUps.length = 0;
  enemies.length = 0;
  shooterEnemies.length = 0;

  updateUI();
  updateLives();
  document.getElementById('currentWeapon').textContent = 'Arma: ' + CONFIG.ships[currentShip].weapons.basic.name;
  document.getElementById('menu').style.display = 'none';
  document.getElementById('shipSelection').style.display = 'none';
  document.getElementById('gameOverScreen').style.display = 'none';

  gameState = 'playing';
}

// Fullscreen
document.getElementById('fullScreenBtn').onclick = () => {
  const el = document.getElementById('gameContainer');
  if (!document.fullscreenElement) el.requestFullscreen();
  else document.exitFullscreen();
};

// Sele칞칚o de naves
document.getElementById('selectShipBtn').onclick = showShipSelection;
document.getElementById('fighterBtn').onclick = () => { currentShip = 'fighter'; startGame(); };
document.getElementById('mothershipBtn').onclick = () => { currentShip = 'mothership'; startGame(); };
document.getElementById('scoutBtn').onclick = () => { currentShip = 'scout'; startGame(); };

// Reiniciar do Game Over leva  sele칞칚o de naves
document.getElementById('restartBtn').onclick = showShipSelection;

// Utilit치rio
Math.clamp = (n, min, max) => Math.max(min, Math.min(max, n));

updateUI();
updateLives();
loop();
</script>
</body>
</html>
