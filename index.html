<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Pendinha Boss Shooter</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  background: #000;
  overflow: hidden;
  font-family: Arial, Helvetica, sans-serif;
}

#gameContainer {
  max-width: 420px;
  margin: 0 auto;
  position: relative;
}

canvas {
  width: 100%;
  display: block;
  background: linear-gradient(#020b18, #000);
}

#ui {
  position: absolute;
  top: 10px;
  left: 10px;
  color: #fff;
  font-size: 14px;
}

#menu {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.85);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #fff;
}

button {
  padding: 10px 20px;
  font-size: 16px;
  cursor: pointer;
}
</style>
</head>

<body>
<div id="gameContainer">
  <canvas id="game" width="360" height="520"></canvas>

  <div id="ui">
    Fase: <span id="phase">1</span><br>
    Score: <span id="score">0</span>
  </div>

  <div id="menu">
    <h2>ðŸ‘¾ Pendinha Boss Shooter</h2>
    <button id="startBtn">â–¶ Iniciar</button>
  </div>
</div>

<script>
/* ==================== BASE ==================== */

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const W = canvas.width;
const H = canvas.height;

let state = "menu";
let score = 0;
let phase = 1;

const uiScore = document.getElementById("score");
const uiPhase = document.getElementById("phase");
const menu = document.getElementById("menu");

/* ==================== INPUT ==================== */

const input = { x: W/2, y: H-60, shoot:false };

canvas.addEventListener("mousemove", e => {
  const r = canvas.getBoundingClientRect();
  input.x = (e.clientX - r.left) * (W / r.width);
  input.y = (e.clientY - r.top) * (H / r.height);
});

canvas.addEventListener("mousedown", () => input.shoot = true);
canvas.addEventListener("mouseup", () => input.shoot = false);

/* ==================== PLAYER ==================== */

const player = {
  x: W/2, y: H-60,
  cooldown: 0,
  bullets: []
};

function shoot() {
  player.bullets.push({ x:player.x, y:player.y, speed:7 });
}

function updatePlayer() {
  player.x += (input.x - player.x) * 0.2;
  player.y += (input.y - player.y) * 0.2;

  player.x = Math.max(15, Math.min(W-15, player.x));
  player.y = Math.max(H/2, Math.min(H-15, player.y));

  if (player.cooldown > 0) player.cooldown--;

  if (input.shoot && player.cooldown === 0) {
    shoot();
    player.cooldown = 12;
  }
}

/* ==================== INIMIGOS PEQUENOS ==================== */

const enemies = [];

function spawnEnemy() {
  enemies.push({
    x: Math.random() * (W-40) + 20,
    y: -20,
    speed: 1.5 + phase * 0.1,
    angle: Math.random() * Math.PI,
    life: 1,
    type: Math.random() < 0.5 ? "zigzag" : "straight"
  });
}

function updateEnemies() {
  enemies.forEach((e, i) => {
    if (e.type === "zigzag") {
      e.x += Math.sin(Date.now()*0.004) * 1.5;
    }
    e.y += e.speed;

    // colisÃ£o com player
    if (Math.hypot(player.x - e.x, player.y - e.y) < 16) {
      gameOver();
    }

    // fora da tela
    if (e.y > H+20) enemies.splice(i,1);
  });
}

/* ==================== BOSS ==================== */

const boss = {
  x: W/2, y: 80,
  life: 100,
  bullets: [],
  timer: 0
};

function resetBoss() {
  boss.life = 100 + phase * 40;
  boss.bullets = [];
}

function updateBoss() {
  boss.timer++;
  if (boss.timer > 40 - phase) {
    boss.timer = 0;
    boss.bullets.push({
      x: boss.x,
      y: boss.y,
      angle: Math.PI/2 + (Math.random()-0.5),
      speed: 2 + phase*0.1
    });
  }

  boss.bullets.forEach((b,i)=>{
    b.x += Math.cos(b.angle)*b.speed;
    b.y += Math.sin(b.angle)*b.speed;

    if (Math.hypot(player.x-b.x, player.y-b.y) < 10) {
      gameOver();
    }

    if (b.y > H) boss.bullets.splice(i,1);
  });
}

/* ==================== UPDATE ==================== */

function update() {
  if (state !== "play") return;

  updatePlayer();
  updateEnemies();
  updateBoss();

  // tiros do player
  player.bullets.forEach((b,i)=>{
    b.y -= b.speed;

    enemies.forEach((e,ei)=>{
      if (Math.hypot(b.x-e.x, b.y-e.y) < 12) {
        enemies.splice(ei,1);
        player.bullets.splice(i,1);
        score += 10;
      }
    });

    if (Math.hypot(b.x-boss.x, b.y-boss.y) < 30) {
      boss.life -= 5;
      player.bullets.splice(i,1);
      score += 5;
      if (boss.life <= 0) nextPhase();
    }

    if (b.y < 0) player.bullets.splice(i,1);
  });

  if (Math.random() < 0.02 + phase*0.005) spawnEnemy();

  uiScore.textContent = score;
  uiPhase.textContent = phase;
}

/* ==================== DRAW ==================== */

function draw() {
  ctx.clearRect(0,0,W,H);

  // player
  ctx.fillStyle="#00e5ff";
  ctx.beginPath();
  ctx.moveTo(player.x, player.y-12);
  ctx.lineTo(player.x-10, player.y+10);
  ctx.lineTo(player.x+10, player.y+10);
  ctx.fill();

  // tiros
  ctx.fillStyle="#00e5ff";
  player.bullets.forEach(b=>{
    ctx.beginPath();
    ctx.arc(b.x,b.y,3,0,Math.PI*2);
    ctx.fill();
  });

  // inimigos
  ctx.fillStyle="#ff9800";
  enemies.forEach(e=>{
    ctx.beginPath();
    ctx.arc(e.x,e.y,8,0,Math.PI*2);
    ctx.fill();
  });

  // boss
  ctx.fillStyle="#b71c1c";
  ctx.beginPath();
  ctx.arc(boss.x,boss.y,32,0,Math.PI*2);
  ctx.fill();

  // boss tiros
  ctx.fillStyle="#ff5252";
  boss.bullets.forEach(b=>{
    ctx.beginPath();
    ctx.arc(b.x,b.y,5,0,Math.PI*2);
    ctx.fill();
  });
}

/* ==================== LOOP ==================== */

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();

/* ==================== FLOW ==================== */

function startGame() {
  score = 0;
  phase = 1;
  enemies.length = 0;
  player.bullets.length = 0;
  resetBoss();
  state = "play";
  menu.style.display = "none";
}

function nextPhase() {
  phase++;
  enemies.length = 0;
  resetBoss();
}

function gameOver() {
  state = "menu";
  menu.style.display = "flex";
}

document.getElementById("startBtn").onclick = startGame;
</script>
</body>
</html>
