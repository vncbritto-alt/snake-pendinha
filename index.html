<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Pendinha Boss Shooter</title>

<style>
* { box-sizing: border-box; }
html, body {
  margin: 0; padding: 0; background: #000; overflow: hidden;
  font-family: Arial, Helvetica, sans-serif; color: #fff;
}
#gameContainer { position: relative; max-width: 420px; margin: auto; }
canvas { width: 100%; display: block; background: #000; }
#ui { position: absolute; top: 10px; left: 10px; z-index: 10; font-size: 14px; pointer-events: none; }
#menu, #gameOverScreen {
  position: absolute; inset: 0; background: rgba(0,0,0,0.9);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  z-index: 20;
}
#menu { display: flex; }
#gameOverScreen { display: none; }
#menu h1, #gameOverScreen h1 { margin-bottom: 20px; font-size: 28px; }
#menu button, #gameOverScreen button {
  padding: 12px 32px; font-size: 18px; cursor: pointer; border: none;
  background: #00e5ff; color: #000; border-radius: 8px; margin-top: 20px;
}
#gameOverScreen p { font-size: 20px; margin: 10px 0; }
</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="game" width="360" height="520"></canvas>

  <div id="ui">
    Fase: <span id="phase">1</span><br>
    Score: <span id="score">0</span>
  </div>

  <div id="menu">
    <h1>ðŸ‘¾ Pendinha Boss Shooter</h1>
    <button id="startBtn">â–¶ Iniciar Jogo</button>
  </div>

  <div id="gameOverScreen">
    <h1>ðŸ’€ Game Over</h1>
    <p>Score Final: <span id="finalScore">0</span></p>
    <p>Fase AlcanÃ§ada: <span id="finalPhase">1</span></p>
    <button id="restartBtn">Jogar Novamente</button>
  </div>
</div>

<script>
// ================= VARIÃVEIS GLOBAIS =================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const W = canvas.width;
const H = canvas.height;

const STATE = { MENU: 0, PLAYING: 1, GAMEOVER: 2 };
let gameState = STATE.MENU;

let score = 0;
let phase = 1;

// Input
const input = { x: W/2, y: H-80, down: false };
canvas.addEventListener("mousemove", e => {
  const r = canvas.getBoundingClientRect();
  input.x = (e.clientX - r.left) * (W / r.width);
  input.y = (e.clientY - r.top) * (H / r.height);
});
canvas.addEventListener("mousedown", () => input.down = true);
canvas.addEventListener("mouseup", () => input.down = false);
canvas.addEventListener("touchstart", e => { e.preventDefault(); input.down = true; });
canvas.addEventListener("touchend", e => { e.preventDefault(); input.down = false; });
canvas.addEventListener("touchmove", e => {
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  input.x = (e.touches[0].clientX - r.left) * (W / r.width);
  input.y = (e.touches[0].clientY - r.top) * (H / r.height);
});

// Background
let bgScroll = 0;
const BG = [
  ["#0b1d13","#1b5e20"], ["#102027","#263238"], ["#1a237e","#0d47a1"],
  ["#311b92","#512da8"], ["#3e2723","#5d4037"], ["#004d40","#00695c"]
];
function drawBackground() {
  bgScroll += 0.6 + phase * 0.08;
  const c = BG[(phase - 1) % BG.length];
  const g = ctx.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0, c[0]); g.addColorStop(1, c[1]);
  ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = "rgba(255,255,255,0.05)";
  for (let i = 0; i < 20; i++) {
    ctx.beginPath();
    ctx.arc((i * 60 + bgScroll) % W, (i * 90 + bgScroll * 0.4) % H, 22, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Player
const player = { x: W/2, y: H-60, size: 16, speed: 0.15, cooldown: 0, bullets: [] };
const WEAPONS = { BASIC: "basic", DOUBLE: "double", SPREAD: "spread", RAPID: "rapid", LASER: "laser" };
let currentWeapon = WEAPONS.BASIC;
let weaponTimer = 0;

function shootPlayer() {
  if (currentWeapon === WEAPONS.BASIC || currentWeapon === WEAPONS.RAPID) {
    player.bullets.push({
      x: player.x, y: player.y - 12, vx: 0,
      vy: currentWeapon === WEAPONS.RAPID ? -10 : -7,
      r: currentWeapon === WEAPONS.RAPID ? 2 : 3,
      laser: false
    });
  }
  if (currentWeapon === WEAPONS.DOUBLE) {
    player.bullets.push(
      { x: player.x - 8, y: player.y - 10, vx: 0, vy: -7, r: 3, laser: false },
      { x: player.x + 8, y: player.y - 10, vx: 0, vy: -7, r: 3, laser: false }
    );
  }
  if (currentWeapon === WEAPONS.SPREAD) {
    [-0.35, 0, 0.35].forEach(a => {
      player.bullets.push({
        x: player.x, y: player.y - 10,
        vx: Math.cos(-Math.PI/2 + a) * 6,
        vy: Math.sin(-Math.PI/2 + a) * 6,
        r: 3, laser: false
      });
    });
  }
  if (currentWeapon === WEAPONS.LASER) {
    player.bullets.push({
      x: player.x, y: player.y - 12, vx: 0, vy: -14, r: 2, laser: true
    });
  }
}

function updatePlayer() {
  if (gameState !== STATE.PLAYING) return;

  player.x += (input.x - player.x) * player.speed;
  player.y += (input.y - player.y) * player.speed;
  player.x = Math.max(player.size, Math.min(W - player.size, player.x));
  player.y = Math.max(player.size, Math.min(H - player.size, player.y));

  if (player.cooldown > 0) player.cooldown--;
  if (input.down && player.cooldown <= 0) {
    shootPlayer();
    player.cooldown = currentWeapon === WEAPONS.RAPID ? 6 : 12;
  }

  for (let i = player.bullets.length - 1; i >= 0; i--) {
    const b = player.bullets[i];
    b.x += b.vx || 0;
    b.y += b.vy;
    if (b.y < -40 || b.x < -40 || b.x > W + 40) player.bullets.splice(i, 1);
  }

  if (weaponTimer > 0) {
    weaponTimer--;
    if (weaponTimer === 0) currentWeapon = WEAPONS.BASIC;
  }
}

function drawPlayer() {
  if (gameState !== STATE.PLAYING) return;
  ctx.fillStyle = "#00e5ff";
  ctx.beginPath(); ctx.moveTo(player.x, player.y - 14);
  ctx.lineTo(player.x - 12, player.y + 12); ctx.lineTo(player.x + 12, player.y + 12);
  ctx.closePath(); ctx.fill();

  ctx.fillStyle = "#ffffff";
  ctx.beginPath(); ctx.arc(player.x, player.y + 2, 3, 0, Math.PI * 2); ctx.fill();
}

function drawPlayerBullets() {
  player.bullets.forEach(b => {
    ctx.fillStyle = b.laser ? "#00ff80" : "#00e5ff";
    ctx.beginPath(); ctx.arc(b.x, b.y, b.r || 3, 0, Math.PI * 2); ctx.fill();
  });
}

// Boss
const boss = { x: W/2, y: 90, radius: 34, life: 300, maxLife: 300, shootTimer: 0, bullets: [], phasePattern: 0 };

function resetBoss() {
  boss.x = W/2; boss.y = 90;
  boss.maxLife = 300 + (phase - 1) * 100; // Aumenta menos rÃ¡pido
  boss.life = boss.maxLife;
  boss.bullets = [];
  boss.shootTimer = 0;
  boss.phasePattern = (phase - 1) % 3;
}

function bossShoot() {
  const difficultyFactor = 1 + (phase - 1) * 0.15; // Aumenta gradualmente
  if (boss.phasePattern === 0) { // leque
    const count = 5 + Math.floor((phase - 1) / 3);
    for (let i = -Math.floor(count/2); i <= Math.floor(count/2); i++) {
      boss.bullets.push({ x: boss.x, y: boss.y, angle: Math.PI / 2 + i * 0.25, speed: 2.4 * difficultyFactor, r: 5, hp: 2 });
    }
  } else if (boss.phasePattern === 1) { // chuva
    const count = 7 + Math.floor((phase - 1) / 2);
    for (let i = -Math.floor(count/2); i <= Math.floor(count/2); i++) {
      boss.bullets.push({ x: boss.x + i * 12, y: boss.y, angle: Math.PI / 2, speed: 3 * difficultyFactor, r: 4, hp: 2 });
    }
  } else { // espiral
    const count = 8 + (phase - 1);
    for (let i = 0; i < count; i++) {
      boss.bullets.push({ x: boss.x, y: boss.y, angle: boss.shootTimer * 0.08 + i * (Math.PI * 2 / count), speed: 2.2 * difficultyFactor, r: 4, hp: 2 });
    }
  }
}

function updateBoss() {
  if (gameState !== STATE.PLAYING) return;

  const baseDelay = 90;
  const shootDelay = Math.max(baseDelay - (phase - 1) * 8, 30); // ComeÃ§a lento, fica mais rÃ¡pido
  boss.shootTimer++;
  if (boss.shootTimer > shootDelay) {
    boss.shootTimer = 0;
    bossShoot();
  }

  // Atualiza balas do boss
  for (let i = boss.bullets.length - 1; i >= 0; i--) {
    const b = boss.bullets[i];
    b.x += Math.cos(b.angle) * b.speed;
    b.y += Math.sin(b.angle) * b.speed;

    if (b.x < -40 || b.x > W + 40 || b.y < -40 || b.y > H + 40) {
      boss.bullets.splice(i, 1);
      continue;
    }

    // ColisÃ£o com player
    if (Math.hypot(player.x - b.x, player.y - b.y) < player.size + b.r) {
      gameOver();
      return;
    }

    // Tiros do player destroem balas do boss (2 hits)
    for (let j = player.bullets.length - 1; j >= 0; j--) {
      const p = player.bullets[j];
      if (Math.hypot(p.x - b.x, p.y - b.y) < b.r + (p.r || 3)) {
        b.hp--;
        player.bullets.splice(j, 1);
        spawnParticles(b.x, b.y, "#ff6f00", 8);
        if (b.hp <= 0) {
          boss.bullets.splice(i, 1);
          score += 10;
          updateUI();
          spawnParticles(b.x, b.y, "#ff1744", 16);
          triggerShake(4, 6);
        }
        break;
      }
    }
  }

  // ColisÃ£o player â†’ boss
  for (let i = player.bullets.length - 1; i >= 0; i--) {
    const p = player.bullets[i];
    if (Math.hypot(p.x - boss.x, p.y - boss.y) < boss.radius + (p.r || 3)) {
      boss.life -= p.laser ? 8 : 5;
      player.bullets.splice(i, 1);
      spawnParticles(boss.x, boss.y, "#ff1744", 18);
      triggerShake(6, 8);
      if (boss.life <= 0) {
        score += 500 + phase * 100;
        phase++;
        updateUI();
        resetBoss();
        triggerShake(14, 18);
      }
    }
  }
}

function drawBoss() {
  ctx.fillStyle = "#b71c1c";
  ctx.beginPath(); ctx.arc(boss.x, boss.y, boss.radius, 0, Math.PI * 2); ctx.fill();

  ctx.fillStyle = "#ff5252";
  ctx.beginPath(); ctx.arc(boss.x, boss.y, 10, 0, Math.PI * 2); ctx.fill();

  const barW = 140;
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(boss.x - barW/2, boss.y - 50, barW, 6);
  ctx.fillStyle = "#e53935";
  ctx.fillRect(boss.x - barW/2, boss.y - 50, barW * (boss.life / boss.maxLife), 6);
}

function drawBossBullets() {
  boss.bullets.forEach(b => {
    ctx.fillStyle = b.hp === 1 ? "#ff8a65" : "#ff1744";
    ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fill();
  });
}

// Inimigos
const enemies = [], shooterEnemies = [], powerUps = [], particles = [];
let enemySpawnTimer = 0, shooterSpawnTimer = 0;
let shake = { t: 0, s: 0 };

function spawnEnemy() {
  const difficulty = 1 + (phase - 1) * 0.1;
  const isMedium = Math.random() < 0.2 + (phase - 1) * 0.03;
  enemies.push({
    x: Math.random() * (W - 60) + 30,
    y: -30,
    vx: (Math.random() - 0.5) * 1.2 * difficulty,
    vy: (isMedium ? 1.1 : 1.6) * difficulty,
    size: isMedium ? 18 : 12,
    life: isMedium ? 3 : 1,
    score: isMedium ? 40 : 15
  });
}

function spawnShooterEnemy() {
  const difficulty = 1 + (phase - 1) * 0.1;
  shooterEnemies.push({
    x: Math.random() * (W - 60) + 30,
    y: -40,
    size: 20,
    life: 4,
    vy: 1.1 * difficulty,
    shootTimer: 0,
    bullets: []
  });
}

function spawnPowerUp(x, y) {
  const list = Object.values(WEAPONS);
  powerUps.push({ x, y, type: list[Math.floor(Math.random() * list.length)], r: 10, vy: 1.2 });
}

function spawnParticles(x, y, color, n = 16) {
  for (let i = 0; i < n; i++) {
    particles.push({ x, y, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 30, c: color });
  }
}

function triggerShake(s=6,t=10){ shake.s=s; shake.t=t; }
function applyShake(){ if(shake.t>0){ shake.t--; ctx.translate((Math.random()-0.5)*shake.s,(Math.random()-0.5)*shake.s); } }

function updatePowerUps() {
  for (let i = powerUps.length - 1; i >= 0; i--) {
    const p = powerUps[i];
    p.y += p.vy;
    if (p.y > H + 20) { powerUps.splice(i, 1); continue; }
    if (Math.hypot(player.x - p.x, player.y - p.y) < player.size + p.r) {
      currentWeapon = p.type;
      weaponTimer = 600;
      powerUps.splice(i, 1);
    }
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function updateEnemiesAndShooters() {
  // Spawn inimigos normais - mais lento no inÃ­cio
  enemySpawnTimer++;
  const baseSpawnRate = 80;
  const spawnRate = Math.max(baseSpawnRate - (phase - 1) * 6, 25);
  if (enemySpawnTimer > spawnRate) {
    enemySpawnTimer = 0;
    spawnEnemy();
  }

  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    e.x += e.vx; e.y += e.vy;
    if (e.y > H + 40) { enemies.splice(i, 1); continue; }
    if (Math.hypot(player.x - e.x, player.y - e.y) < player.size + e.size) { gameOver(); return; }

    for (let j = player.bullets.length - 1; j >= 0; j--) {
      const b = player.bullets[j];
      if (Math.hypot(b.x - e.x, b.y - e.y) < e.size + (b.r || 3)) {
        e.life--;
        player.bullets.splice(j, 1);
        if (e.life <= 0) {
          score += e.score;
          updateUI();
          if (Math.random() < 0.12 + (phase - 1) * 0.01) spawnPowerUp(e.x, e.y);
          enemies.splice(i, 1);
        }
        break;
      }
    }
  }

  // Spawn shooters - aparece sÃ³ a partir da fase 3
  if (phase >= 3) {
    shooterSpawnTimer++;
    const shooterRate = Math.max(300 - (phase - 1) * 20, 100);
    if (shooterSpawnTimer > shooterRate) {
      shooterSpawnTimer = 0;
      spawnShooterEnemy();
    }
  }

  for (let i = shooterEnemies.length - 1; i >= 0; i--) {
    const e = shooterEnemies[i];
    e.y += e.vy;
    e.shootTimer++;
    if (e.y > H + 50) { shooterEnemies.splice(i, 1); continue; }

    if (e.shootTimer > 70 - (phase - 1) * 3) {
      e.shootTimer = 0;
      e.bullets.push({ x: e.x, y: e.y, angle: Math.PI / 2, speed: 2.6 + (phase - 1) * 0.1, r: 4, hp: 2 });
    }

    for (let j = e.bullets.length - 1; j >= 0; j--) {
      const b = e.bullets[j];
      b.x += Math.cos(b.angle) * b.speed;
      b.y += Math.sin(b.angle) * b.speed;
      if (Math.hypot(player.x - b.x, player.y - b.y) < player.size + b.r) { gameOver(); return; }
      if (b.y > H + 30) e.bullets.splice(j, 1);

      // Player pode destruir balas dos shooters tambÃ©m
      for (let k = player.bullets.length - 1; k >= 0; k--) {
        const p = player.bullets[k];
        if (Math.hypot(p.x - b.x, p.y - b.y) < b.r + (p.r || 3)) {
          b.hp--;
          player.bullets.splice(k, 1);
          if (b.hp <= 0) {
            e.bullets.splice(j, 1);
            score += 10;
            updateUI();
            spawnParticles(b.x, b.y, "#ff1744", 12);
          }
          break;
        }
      }
    }

    for (let j = player.bullets.length - 1; j >= 0; j--) {
      const b = player.bullets[j];
      if (Math.hypot(b.x - e.x, b.y - e.y) < e.size + (b.r || 3)) {
        e.life--;
        player.bullets.splice(j, 1);
        if (e.life <= 0) {
          score += 80;
          updateUI();
          if (Math.random() < 0.25) spawnPowerUp(e.x, e.y);
          shooterEnemies.splice(i, 1);
        }
        break;
      }
    }
  }
}

function drawEnemies() {
  enemies.forEach(e => {
    ctx.fillStyle = e.life === 1 ? "#ffeb3b" : "#ff9800";
    ctx.beginPath();
    ctx.moveTo(e.x, e.y - e.size);
    ctx.lineTo(e.x - e.size, e.y + e.size);
    ctx.lineTo(e.x + e.size, e.y + e.size);
    ctx.closePath(); ctx.fill();

    ctx.fillStyle = "#000";
    ctx.beginPath(); ctx.arc(e.x, e.y + 3, 3, 0, Math.PI * 2); ctx.fill();
  });
}

function drawShooterEnemies() {
  shooterEnemies.forEach(e => {
    ctx.fillStyle = "#f44336";
    ctx.fillRect(e.x - 12, e.y - 12, 24, 24);

    ctx.fillStyle = "#ffcdd2";
    ctx.beginPath(); ctx.arc(e.x, e.y, 4, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = "#ff5252";
    e.bullets.forEach(b => {
      ctx.fillStyle = b.hp === 1 ? "#ff8a65" : "#ff5252";
      ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fill();
    });
  });
}

function drawPowerUps() {
  powerUps.forEach(p => {
    ctx.fillStyle = "#00e676";
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = "#000"; ctx.font = "10px Arial";
    ctx.fillText(p.type[0].toUpperCase(), p.x - 3, p.y + 4);
  });
}

function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life / 30;
    ctx.fillStyle = p.c;
    ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill();
  });
  ctx.globalAlpha = 1;
}

// UI
function updateUI() {
  document.getElementById("score").textContent = score;
  document.getElementById("phase").textContent = phase;
}

let uiPulse = 0;
function drawAnimatedUI() {
  uiPulse += 0.05;
  const sc = 1 + Math.sin(uiPulse) * 0.05;
  ctx.save(); ctx.translate(10,24); ctx.scale(sc,sc);
  ctx.fillStyle="#fff"; ctx.font="bold 16px Arial"; ctx.fillText("Score: "+score,0,0);
  ctx.restore();
  ctx.save(); ctx.translate(10,48); ctx.scale(sc,sc);
  ctx.fillText("Fase: "+phase,0,0); ctx.restore();
}

// Game Over
function gameOver() {
  gameState = STATE.GAMEOVER;
  document.getElementById("finalScore").textContent = score;
  document.getElementById("finalPhase").textContent = phase;
  document.getElementById("gameOverScreen").style.display = "flex";
}

function startGame() {
  score = 0; phase = 1;
  player.bullets = []; boss.bullets = [];
  enemies.length = 0; shooterEnemies.length = 0;
  powerUps.length = 0; particles.length = 0;
  enemySpawnTimer = 0; shooterSpawnTimer = 0;
  weaponTimer = 0; currentWeapon = WEAPONS.BASIC;
  resetBoss();
  updateUI();
  gameState = STATE.PLAYING;
  document.getElementById("menu").style.display = "none";
  document.getElementById("gameOverScreen").style.display = "none";
}

// Main Loop
function update() {
  if (gameState === STATE.PLAYING) {
    updatePlayer();
    updateBoss();
    updateEnemiesAndShooters();
    updatePowerUps();
    updateParticles();
  }
}

function render() {
  ctx.save();
  drawBackground();
  applyShake();

  if (gameState === STATE.PLAYING) {
    drawBoss(); drawBossBullets();
    drawEnemies(); drawShooterEnemies();
    drawPlayer(); drawPlayerBullets();
    drawPowerUps(); drawParticles();
    drawAnimatedUI();
  }

  ctx.restore();
}

function loop() {
  update();
  render();
  requestAnimationFrame(loop);
}
loop();

// BotÃµes
document.getElementById("startBtn").onclick = startGame;
document.getElementById("restartBtn").onclick = startGame;

// Init
resetBoss();
updateUI();
</script>

</body>
</html>
