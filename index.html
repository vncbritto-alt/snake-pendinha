<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Pendinha Boss Shooter</title>
<style>
  * { box-sizing: border-box; }
  html, body {
    margin: 0; padding: 0; height: 100%; background: #000;
    font-family: 'Arial', sans-serif; color: #fff; touch-action: manipulation;
  }
  #gameContainer {
    position: relative; max-width: 420px; margin: 0 auto; height: 100%;
    display: flex; align-items: center; justify-content: center; background: #000;
  }
  canvas { display: block; background: #000; image-rendering: pixelated; }
  #ui, #lives, #currentWeapon, #fullScreenBtn {
    position: absolute; z-index: 10; pointer-events: none; user-select: none;
  }
  #ui { top: 12px; left: 12px; font-size: 15px; font-weight: bold; }
  #lives { top: 12px; right: 12px; font-size: 28px; }
  #currentWeapon { bottom: 12px; left: 12px; font-size: 14px; color: #00e5ff; }
  #fullScreenBtn {
    bottom: 12px; right: 12px; padding: 10px 14px; background: rgba(0,229,255,0.9);
    color: #000; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;
    pointer-events: auto;
  }
  #menu, #gameOverScreen {
    position: absolute; inset: 0; background: rgba(0,0,0,0.94);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 20; text-align: center;
  }
  #menu { display: flex; }
  #gameOverScreen { display: none; }
  #menu h1 { font-size: 36px; margin-bottom: 10px; }
  #menu p { margin: 10px 0; opacity: 0.9; }
  button {
    padding: 14px 36px; font-size: 20px; margin-top: 20px;
    background: #00e5ff; color: #000; border: none; border-radius: 10px;
    cursor: pointer; font-weight: bold;
  }
  button:active { transform: scale(0.95); }
  #gameOverScreen h1 { color: #ff1744; }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="game"></canvas>
  <div id="ui">
    Fase: <span id="phase">1</span><br>
    Score: <span id="score">0</span>
  </div>
  <div id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
  <div id="currentWeapon">Arma: B√°sica</div>
  <button id="fullScreenBtn">üì∫ Tela Cheia</button>

  <div id="menu">
    <h1>üëæ Pendinha Boss Shooter</h1>
    <p>Toque ou mova o mouse para controlar<br>Segure para atirar</p>
    <button id="startBtn">‚ñ∂ Iniciar Jogo</button>
  </div>

  <div id="gameOverScreen">
    <h1>üíÄ Game Over</h1>
    <p>Score Final: <span id="finalScore">0</span></p>
    <p>Fase Alcan√ßada: <span id="finalPhase">1</span></p>
    <button id="restartBtn">Jogar Novamente</button>
  </div>
</div>

<script>
// ================ CONFIGURA√á√ïES ================
const CONFIG = {
  canvas: { width: 360, height: 520 },
  player: { size: 16, speed: 0.18 },
  weapons: {
    basic: { name: "B√°sica", cooldown: 12, bullet: { vy: -7, r: 3, damage: 5 } },
    double: { name: "Dupla", cooldown: 14, offset: 10 },
    spread: { name: "Espalhada", cooldown: 16, angles: [-0.35, 0, 0.35] },
    rapid: { name: "R√°pida", cooldown: 6, bullet: { vy: -10, r: 2, damage: 5 } },
    laser: { name: "Laser", cooldown: 10, bullet: { vy: -14, r: 2, laser: true, damage: 8 } }
  },
  powerUpDuration: 600,
  allyDuration: 1200,
  maxLives: 3
};

// ================ ESTADO GLOBAL ================
let gameState = 'menu';
let score = 0;
let phase = 1;
let lives = CONFIG.maxLives;
let currentWeapon = 'basic';
let weaponTimer = 0;
let ally = null;

// ================ CANVAS E INPUT ================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = CONFIG.canvas.width;
canvas.height = CONFIG.canvas.height;

const input = { x: canvas.width / 2, y: canvas.height - 80, active: false };

['mousemove', 'touchmove'].forEach(ev => {
  canvas.addEventListener(ev, e => {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    input.x = (clientX - rect.left) * (canvas.width / rect.width);
    input.y = (clientY - rect.top) * (canvas.height / rect.height);
  });
});

['mousedown', 'touchstart'].forEach(ev => {
  canvas.addEventListener(ev, e => { e.preventDefault(); input.active = true; });
});
['mouseup', 'touchend', 'touchcancel'].forEach(ev => {
  canvas.addEventListener(ev, () => input.active = false);
});

// ================ ENTIDADES ================
class Player {
  constructor() {
    this.x = canvas.width / 2;
    this.y = canvas.height - 60;
    this.cooldown = 0;
    this.bullets = [];
  }
  update() {
    this.x += (input.x - this.x) * CONFIG.player.speed;
    this.y += (input.y - this.y) * CONFIG.player.speed;
    this.x = Math.clamp(this.x, CONFIG.player.size, canvas.width - CONFIG.player.size);
    this.y = Math.clamp(this.y, CONFIG.player.size, canvas.height - CONFIG.player.size);

    if (this.cooldown > 0) this.cooldown--;
    if (input.active && this.cooldown <= 0) {
      this.shoot();
      this.cooldown = CONFIG.weapons[currentWeapon].cooldown || 12;
    }

    for (let i = this.bullets.length - 1; i >= 0; i--) {
      const b = this.bullets[i];
      b.x += b.vx || 0;
      b.y += b.vy;
      if (b.y < -50 || b.x < -50 || b.x > canvas.width + 50) {
        this.bullets.splice(i, 1);
      }
    }
  }
  shoot() {
    const w = CONFIG.weapons[currentWeapon];
    if (currentWeapon === 'double') {
      this.bullets.push(
        { x: this.x - w.offset, y: this.y - 10, vx: 0, vy: -7, r: 3, damage: 5 },
        { x: this.x + w.offset, y: this.y - 10, vx: 0, vy: -7, r: 3, damage: 5 }
      );
    } else if (currentWeapon === 'spread') {
      w.angles.forEach(a => {
        const speed = 6;
        this.bullets.push({
          x: this.x, y: this.y - 10,
          vx: Math.cos(-Math.PI/2 + a) * speed,
          vy: Math.sin(-Math.PI/2 + a) * speed,
          r: 3, damage: 5
        });
      });
    } else {
      const bullet = { x: this.x, y: this.y - 12, vx: 0, ...w.bullet };
      this.bullets.push(bullet);
    }
  }
  draw() {
    ctx.fillStyle = '#00e5ff';
    ctx.beginPath();
    ctx.moveTo(this.x, this.y - 14);
    ctx.lineTo(this.x - 12, this.y + 12);
    ctx.lineTo(this.x + 12, this.y + 12);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(this.x, this.y + 2, 4, 0, Math.PI * 2);
    ctx.fill();
  }
}

class Boss {
  constructor() { this.reset(); }
  reset() {
    this.x = canvas.width / 2;
    this.y = 90;
    this.radius = 36;
    this.maxLife = 300 + (phase - 1) * 120;
    this.life = this.maxLife;
    this.bullets = [];
    this.shootTimer = 0;
    this.pattern = (phase - 1) % 3;
  }
  update() {
    const diff = 1 + (phase - 1) * 0.15;
    const delay = Math.max(90 - (phase - 1) * 8, 35);
    if (++this.shootTimer >= delay) {
      this.shootTimer = 0;
      this.shoot(diff);
    }

    for (let i = this.bullets.length - 1; i >= 0; i--) {
      const b = this.bullets[i];
      b.x += Math.cos(b.angle) * b.speed;
      b.y += Math.sin(b.angle) * b.speed;
      if (b.x < -50 || b.x > canvas.width + 50 || b.y < -50 || b.y > canvas.height + 50) {
        this.bullets.splice(i, 1);
      }
    }
  }
  shoot(diff) {
    if (this.pattern === 0) {
      const count = 6 + Math.floor(phase / 3);
      for (let i = -Math.floor(count / 2); i <= Math.floor(count / 2); i++) {
        this.bullets.push({ x: this.x, y: this.y, angle: Math.PI / 2 + i * 0.22, speed: 2.6 * diff, r: 6 });
      }
    } else if (this.pattern === 1) {
      for (let i = -3; i <= 3; i++) {
        this.bullets.push({ x: this.x + i * 16, y: this.y, angle: Math.PI / 2, speed: 3.2 * diff, r: 5 });
      }
    } else {
      const count = 10 + phase;
      for (let i = 0; i < count; i++) {
        const angle = i * Math.PI * 2 / count + performance.now() * 0.001;
        this.bullets.push({ x: this.x, y: this.y, angle, speed: 2.4 * diff, r: 5 });
      }
    }
  }
  draw() {
    ctx.fillStyle = '#b71c1c';
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#ff1744';
    ctx.beginPath();
    ctx.arc(this.x, this.y - 8, 12, 0, Math.PI * 2);
    ctx.fill();

    const barW = 160;
    ctx.fillStyle = '#333';
    ctx.fillRect(this.x - barW / 2, this.y - 56, barW, 10);
    ctx.fillStyle = '#4caf50';
    ctx.fillRect(this.x - barW / 2, this.y - 56, barW * (this.life / this.maxLife), 10);
  }
}

// ================ OUTRAS ENTIDADES ================
const player = new Player();
let boss = new Boss();

const particles = [];
const powerUps = [];
const enemies = [];
const shooterEnemies = [];

let shake = 0;
let bgOffset = 0;

const bgColors = [
  ["#0b1d13","#1b5e20"], ["#102027","#263238"], ["#1a237e","#0d47a1"],
  ["#311b92","#512da8"], ["#3e2723","#5d4037"], ["#004d40","#00695c"]
];

function spawnParticles(x, y, color = '#ff1744', count = 20) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.5) * 6,
      life: 30 + Math.random() * 20,
      color
    });
  }
}

function triggerShake(amount = 8) {
  shake = Math.max(shake, amount);
}

function spawnPowerUp(x, y) {
  const types = ['double', 'spread', 'rapid', 'laser'];
  let type = types[Math.floor(Math.random() * types.length)];
  if (Math.random() < 0.1 && lives < CONFIG.maxLives) type = 'life';
  if (Math.random() < 0.08) type = 'ally';
  powerUps.push({ x, y, type, vy: 1.4, r: 14 });
}

// ================ UPDATE ================
function update() {
  if (gameState !== 'playing') return;

  player.update();
  boss.update();

  // Shake decay
  if (shake > 0) shake = Math.max(0, shake - 0.6);

  // Spawn inimigos simples
  if (Math.random() < 0.015 + phase * 0.003) {
    enemies.push({
      x: Math.random() * (canvas.width - 40) + 20,
      y: -30,
      size: Math.random() < 0.3 ? 18 : 12,
      life: Math.random() < 0.3 ? 3 : 1,
      vy: 1.4 + phase * 0.1
    });
  }

  // Spawn inimigos atiradores
  if (Math.random() < 0.005 + phase * 0.001) {
    shooterEnemies.push({
      x: Math.random() * (canvas.width - 40) + 20,
      y: -40,
      size: 20,
      life: 4,
      vy: 1.1 + phase * 0.1,
      shootTimer: Math.random() * 40
    });
  }

  // Update inimigos simples
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    e.y += e.vy;
    if (e.y > canvas.height + 40) enemies.splice(i, 1);
  }

  // Update inimigos atiradores
  for (let i = shooterEnemies.length - 1; i >= 0; i--) {
    const se = shooterEnemies[i];
    se.y += se.vy;
    if (++se.shootTimer >= 60) {
      se.shootTimer = 0;
      boss.bullets.push({
        x: se.x, y: se.y + se.size, angle: Math.PI / 2,
        speed: 3 + phase * 0.1, r: 4
      });
    }
    if (se.y > canvas.height + 40) shooterEnemies.splice(i, 1);
  }

  // Power-ups
  for (let i = powerUps.length - 1; i >= 0; i--) {
    const p = powerUps[i];
    p.y += p.vy;
    if (Math.hypot(p.x - player.x, p.y - player.y) < CONFIG.player.size + p.r) {
      applyPowerUp(p.type);
      spawnParticles(p.x, p.y, '#00ff80', 30);
      powerUps.splice(i, 1);
    } else if (p.y > canvas.height + 30) {
      powerUps.splice(i, 1);
    }
  }

  // Part√≠culas
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Colis√µes
  checkCollisions();

  // Timer de arma tempor√°ria
  if (weaponTimer > 0 && --weaponTimer === 0) {
    currentWeapon = 'basic';
    document.getElementById('currentWeapon').textContent = 'Arma: B√°sica';
  }

  // Ally
  if (ally) {
    ally.timer--;
    ally.x += (player.x + ally.offset - ally.x) * 0.12;
    ally.y += (player.y - 50 - ally.y) * 0.1;
    if (ally.shootTimer-- <= 0) {
      player.bullets.push({ x: ally.x, y: ally.y, vx: 0, vy: -9, r: 3, damage: 5 });
      ally.shootTimer = 18;
    }
    if (ally.timer <= 0) ally = null;
  }
}

function applyPowerUp(type) {
  if (type === 'life') {
    lives = Math.min(lives + 1, CONFIG.maxLives);
    updateLives();
  } else if (type === 'ally') {
    ally = { x: player.x - 60, y: player.y - 40, offset: -60, timer: CONFIG.allyDuration, shootTimer: 0 };
  } else {
    currentWeapon = type;
    weaponTimer = CONFIG.powerUpDuration;
    document.getElementById('currentWeapon').textContent = 'Arma: ' + CONFIG.weapons[type].name;
  }
}

function checkCollisions() {
  // Tiros do player no boss
  for (let i = player.bullets.length - 1; i >= 0; i--) {
    const b = player.bullets[i];
    if (Math.hypot(b.x - boss.x, b.y - boss.y) < boss.radius + (b.r || 3)) {
      boss.life -= b.damage || 5;
      player.bullets.splice(i, 1);
      spawnParticles(boss.x, boss.y, '#ff5722', 12);
      triggerShake(6);
      if (boss.life <= 0) {
        score += 800 + phase * 200;
        phase++;
        updateUI();
        boss.reset();
        triggerShake(16);
        spawnParticles(boss.x, boss.y, '#ffeb3b', 60);
        spawnPowerUp(boss.x, boss.y);
      }
    }
  }

  // Tiros do player em inimigos
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    for (let j = player.bullets.length - 1; j >= 0; j--) {
      const b = player.bullets[j];
      if (Math.hypot(b.x - e.x, b.y - e.y) < e.size + (b.r || 3)) {
        e.life -= b.damage || 5;
        player.bullets.splice(j, 1);
        if (e.life <= 0) {
          score += e.size > 15 ? 50 : 20;
          updateUI();
          spawnParticles(e.x, e.y, '#ff9800', 15);
          enemies.splice(i, 1);
          if (Math.random() < 0.25) spawnPowerUp(e.x, e.y);
          break;
        }
      }
    }
  }

  // Tiros do player em atiradores
  for (let i = shooterEnemies.length - 1; i >= 0; i--) {
    const se = shooterEnemies[i];
    for (let j = player.bullets.length - 1; j >= 0; j--) {
      const b = player.bullets[j];
      if (Math.hypot(b.x - se.x, b.y - se.y) < se.size + (b.r || 3)) {
        se.life -= b.damage || 5;
        player.bullets.splice(j, 1);
        if (se.life <= 0) {
          score += 80;
          updateUI();
          spawnParticles(se.x, se.y, '#ff5722', 20);
          shooterEnemies.splice(i, 1);
          if (Math.random() < 0.35) spawnPowerUp(se.x, se.y);
          break;
        }
      }
    }
  }

  // Colis√£o com player (tiros do boss e inimigos)
  const allEnemyBulletsAndEntities = [...boss.bullets, ...enemies, ...shooterEnemies];
  for (let i = allEnemyBulletsAndEntities.length - 1; i >= 0; i--) {
    const obj = allEnemyBulletsAndEntities[i];
    const radius = obj.r || obj.size;
    if (Math.hypot(obj.x - player.x, obj.y - player.y) < radius + CONFIG.player.size) {
      lives--;
      updateLives();
      triggerShake(12);
      spawnParticles(player.x, player.y, '#ff1744', 40);
      if (obj.r) boss.bullets = boss.bullets.filter(b => b !== obj); // remove tiro
      if (lives <= 0) {
        gameOver();
        return;
      }
    }
  }
}

// ================ RENDER ================
function drawBackground() {
  bgOffset += 0.6 + phase * 0.08;
  const colors = bgColors[(phase - 1) % bgColors.length];
  const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grad.addColorStop(0, colors[0]);
  grad.addColorStop(1, colors[1]);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  for (let i = 0; i < 18; i++) {
    const x = (i * 50 + bgOffset) % canvas.width;
    const y = (i * 80 + bgOffset * 0.5) % canvas.height;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();
  }
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBackground();

  let shakeX = 0, shakeY = 0;
  if (shake > 0) {
    shakeX = (Math.random() - 0.5) * shake;
    shakeY = (Math.random() - 0.5) * shake;
    ctx.translate(shakeX, shakeY);
  }

  if (gameState === 'playing') {
    // Boss
    boss.draw();
    boss.bullets.forEach(b => {
      ctx.fillStyle = '#ff5252';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();
    });

    // Inimigos simples
    enemies.forEach(e => {
      ctx.fillStyle = e.size > 15 ? '#ff5722' : '#ff9800';
      ctx.beginPath();
      ctx.moveTo(e.x, e.y - e.size);
      ctx.lineTo(e.x - e.size, e.y + e.size);
      ctx.lineTo(e.x + e.size, e.y + e.size);
      ctx.closePath();
      ctx.fill();
    });

    // Inimigos atiradores
    shooterEnemies.forEach(se => {
      ctx.fillStyle = '#795548';
      ctx.beginPath();
      ctx.moveTo(se.x, se.y - se.size);
      ctx.lineTo(se.x - se.size, se.y + se.size);
      ctx.lineTo(se.x + se.size, se.y + se.size);
      ctx.closePath();
      ctx.fill();
    });

    // Power-ups
    powerUps.forEach(p => {
      const colors = { double: '#ffeb3b', spread: '#e91e63', rapid: '#00bcd4', laser: '#00ff80', life: '#f44336', ally: '#8bc34a' };
      ctx.fillStyle = colors[p.type] || '#fff';
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.stroke();
    });

    // Ally
    if (ally) {
      ctx.fillStyle = '#00ff80';
      ctx.beginPath();
      ctx.moveTo(ally.x, ally.y - 12);
      ctx.lineTo(ally.x - 10, ally.y + 10);
      ctx.lineTo(ally.x + 10, ally.y + 10);
      ctx.closePath();
      ctx.fill();
    }

    // Tiros do player
    player.bullets.forEach(b => {
      ctx.fillStyle = b.laser ? '#00ff80' : '#00e5ff';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r || 3, 0, Math.PI * 2);
      ctx.fill();
    });

    // Player
    player.draw();

    // Part√≠culas
    particles.forEach(p => {
      ctx.globalAlpha = p.life / 50;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
    });
    ctx.globalAlpha = 1;
  }

  if (shake > 0) ctx.translate(-shakeX, -shakeY);
}

function loop() {
  update();
  render();
  requestAnimationFrame(loop);
}

// ================ UI E CONTROLES ================
function updateUI() {
  document.getElementById('score').textContent = score;
  document.getElementById('phase').textContent = phase;
}

function updateLives() {
  document.getElementById('lives').textContent = '‚ù§Ô∏è'.repeat(lives);
}

function gameOver() {
  gameState = 'gameover';
  document.getElementById('finalScore').textContent = score;
  document.getElementById('finalPhase').textContent = phase;
  document.getElementById('gameOverScreen').style.display = 'flex';
}

function startGame() {
  score = 0;
  phase = 1;
  lives = CONFIG.maxLives;
  currentWeapon = 'basic';
  weaponTimer = 0;
  ally = null;

  player.x = canvas.width / 2;
  player.y = canvas.height - 60;
  player.bullets = [];

  boss.reset();

  particles.length = 0;
  powerUps.length = 0;
  enemies.length = 0;
  shooterEnemies.length = 0;

  updateUI();
  updateLives();
  document.getElementById('currentWeapon').textContent = 'Arma: B√°sica';
  document.getElementById('menu').style.display = 'none';
  document.getElementById('gameOverScreen').style.display = 'none';

  gameState = 'playing';
}

// Fullscreen
document.getElementById('fullScreenBtn').onclick = () => {
  const el = document.getElementById('gameContainer');
  if (!document.fullscreenElement) el.requestFullscreen();
  else document.exitFullscreen();
};

// Utilit√°rio
Math.clamp = (n, min, max) => Math.max(min, Math.min(max, n));

// Inicializa√ß√£o
document.getElementById('startBtn').onclick = startGame;
document.getElementById('restartBtn').onclick = startGame;

updateUI();
updateLives();
loop();
</script>
</body>
</html>
